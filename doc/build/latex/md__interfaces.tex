\label{md__interfaces_Interfaces}%
\hypertarget{md__interfaces_Interfaces}{}%


In faudio, an {\itshape interface} (not to be confuseed with and {\itshape audio interface}) is a collection of function types, identified by a unique value known as the {\itshape interface identifier}. They are used extensively inside faudio.

In {\itshape faudio}, all non-\/primitive types are defined as \href{http://en.wikipedia.org/wiki/Reference_type}{\tt reference types}, and may provide implementations for an arbitrary number of interfaces by implementing a so-\/called {\itshape dispatch function}, which takes a reference of the given type and an interface identifier and returns a pointer to a structure conforming to the interface type. This structure is known as an {\itshape implementation}.

Interfaces can be used to decorate a type with additional semantics such as \hyperlink{structfa__equal__t}{equality} or \hyperlink{structfa__order__t}{ordering}. Another use is to overload common functionality, such as \hyperlink{structfa__number__t}{arithmetic operators}.


\begin{DoxyCode}
\hyperlink{group___fa_list_ga35ecb12ab934ded0cce0bcf28e3bc5d2}{fa\_list\_t} numbers1 = fa\_list\_of(\hyperlink{util_8h_a832509ea197065489f1d60b6d7958cbf}{i32}, 1, 2, 3, 4, 5);
\hyperlink{group___fa_list_ga35ecb12ab934ded0cce0bcf28e3bc5d2}{fa\_list\_t} numbers2 = fa\_list\_of(\hyperlink{util_8h_a832509ea197065489f1d60b6d7958cbf}{i32}, 6, 7, 8);

\hyperlink{group___fa_ga60d1e34d8101c4f20d7e5473c90766a2}{fa\_print}(\textcolor{stringliteral}{"%b"}, \hyperlink{group___fa_ga4747e94dca95afaf031d6b00c36cc8fc}{fa\_less\_than}(numbers1, numbers2));
\end{DoxyCode}
\hypertarget{md__interfaces_Using}{}\section{Using an interface}\label{md__interfaces_Using}
Interface methods are called by invoking \hyperlink{group___fa_ga1cc4276643f3d366681ac7ff71fa8b06}{fa\-\_\-interface}, passing the interface identifier and the value on which the interface is going to be dispatched. This is usually one of the arguments to the invoked method, but it can be any value. If the given value does not implement the interface, \hyperlink{group___fa_ga1cc4276643f3d366681ac7ff71fa8b06}{fa\-\_\-interface} returns {\ttfamily N\-U\-L\-L}.

Note that \hyperlink{group___fa_ga1cc4276643f3d366681ac7ff71fa8b06}{fa\-\_\-interface} is actually the {\itshape only} way to call an interface method\-: in particular it is not safe to cast a pointer of some type to the interface type and call the methods from that pointer. It follows that you must not use a pointer to an interface type (such as \hyperlink{structfa__equal__t}{fa\-\_\-equal\-\_\-t}) as an argument to \hyperlink{group___fa_ga1cc4276643f3d366681ac7ff71fa8b06}{fa\-\_\-interface}.\hypertarget{md__interfaces_GenericFunctions}{}\subsection{Generic functions}\label{md__interfaces_GenericFunctions}
Interfaces are commonly used to implement generic functions, which are functions using an interface method without knowledge of the exact type. Generic functions generally accept one or more parameters of type {\ttfamily void $\ast$}.

For example, this is a way to implement the {\itshape min} function for any type supporing the \hyperlink{structfa__order__t}{fa\-\_\-order\-\_\-t} interface.


\begin{DoxyCode}
\textcolor{keywordtype}{void} * \hyperlink{group___fa_ga81600d57c9bde20b7e9be906b1b37447}{fa\_min}(\textcolor{keywordtype}{void} *a, \textcolor{keywordtype}{void} *b) 
\{             
    \textcolor{keywordflow}{return} \hyperlink{group___fa_ga1cc4276643f3d366681ac7ff71fa8b06}{fa\_interface}(\hyperlink{interfaces_8h_a7c337b4de759549a84c656770ce01cd2ae08a92558a44d2796dc2a5df8ff1b3c3}{fa\_order\_i}, a)->less\_than(a, b) ? a : b;
\}
\end{DoxyCode}


Note that most interfaces define generic functions wrapping their methods, saving the user from having to write an explicit \hyperlink{group___fa_ga1cc4276643f3d366681ac7ff71fa8b06}{fa\-\_\-interface} call. By convention, the wrapper should be a function of the same name as the interface method. Thus the above function could be defined more briefly as follows.


\begin{DoxyCode}
\textcolor{keywordtype}{void} * \hyperlink{group___fa_ga81600d57c9bde20b7e9be906b1b37447}{fa\_min}(\textcolor{keywordtype}{void} *a, \textcolor{keywordtype}{void} *b)
\{
    \textcolor{keywordflow}{return} \hyperlink{group___fa_ga4747e94dca95afaf031d6b00c36cc8fc}{fa\_less\_than}(a, b) ? a : b;
\}
\end{DoxyCode}


Note that the restriction on arguments to generic functions correspond to {\itshape universal} quantification (i.\-e. it says {\itshape for any type} a {\itshape such that} a {\itshape implements the equal interface}).\hypertarget{md__interfaces_GenericPointers}{}\subsection{Generic values}\label{md__interfaces_GenericPointers}
T\-O\-D\-O

Note that restriction on generic values correspond to {\itshape existential} quantification (i.\-e. it says {\itshape for some type} a {\itshape such that} a {\itshape implements the equal interface}).\hypertarget{md__interfaces_DynInterfaceCheck}{}\subsection{Dynamic checks}\label{md__interfaces_DynInterfaceCheck}
As \hyperlink{group___fa_ga1cc4276643f3d366681ac7ff71fa8b06}{fa\-\_\-interface} returns a pointer to the interface or {\ttfamily null}, it can be used for dynamically inspecting a whether an arbitrary value supports an interface or not. If a type is known to support an interface at compile-\/time, this check can be omitted.

This is a way to implement a safe equality check, which compares using the equal interface if the given value implements it, and compares their addresses otherwise.


\begin{DoxyCode}
\textcolor{keywordtype}{bool} safe\_equal(\textcolor{keywordtype}{void} *a, \textcolor{keywordtype}{void} *b)
\{       
    \hyperlink{structfa__equal__t}{fa\_equal\_t} *equal = \hyperlink{group___fa_ga1cc4276643f3d366681ac7ff71fa8b06}{fa\_interface}(\hyperlink{interfaces_8h_a7c337b4de759549a84c656770ce01cd2a9b8bb278c9a713e6ec54d275002e0a01}{fa\_equal\_i}, a);

    \textcolor{keywordflow}{if} (equal)
        \textcolor{keywordflow}{return} equal->\hyperlink{structfa__equal__t_acd1ed940afe1760fc0246fb6e774445f}{equal}(a, b);
    \textcolor{keywordflow}{else}
        \textcolor{keywordflow}{return} a == b;
\}
\end{DoxyCode}
\hypertarget{md__interfaces_Defining}{}\section{Defining an interface}\label{md__interfaces_Defining}
To define a new interface, the following has to be provided\-:


\begin{DoxyItemize}
\item An interface struct
\item An interface identifier
\end{DoxyItemize}

The struct is simply a typedef defining the types of the interface, for example


\begin{DoxyCode}
\textcolor{keyword}{typedef} \textcolor{keyword}{struct }\{

    bool (* less\_than)(\textcolor{keywordtype}{void} *, \textcolor{keywordtype}{void} *);

    bool (* greater\_than)(\textcolor{keywordtype}{void} *, \textcolor{keywordtype}{void} *);

\} \hyperlink{structfa__order__t}{fa\_order\_t};
\end{DoxyCode}


The identifier should be defined as a macro or enum constant defining a unique number.


\begin{DoxyCode}
\textcolor{keyword}{enum} \{ \hyperlink{interfaces_8h_a7c337b4de759549a84c656770ce01cd2ae08a92558a44d2796dc2a5df8ff1b3c3}{fa\_order\_i} = 255; \};
\end{DoxyCode}


As described above, it is good style to also provide a generic function wrapping each method\-:


\begin{DoxyCode}
\textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \hyperlink{group___fa_ga4747e94dca95afaf031d6b00c36cc8fc}{fa\_less\_than} (\textcolor{keywordtype}{void} *, \textcolor{keywordtype}{void} *)
\{
    \textcolor{keywordflow}{return} \hyperlink{group___fa_ga1cc4276643f3d366681ac7ff71fa8b06}{fa\_interface}(\hyperlink{interfaces_8h_a7c337b4de759549a84c656770ce01cd2ae08a92558a44d2796dc2a5df8ff1b3c3}{fa\_order\_i}, a)->less\_than(a, b);
\}

\textcolor{keyword}{inline} \textcolor{keywordtype}{bool} \hyperlink{group___fa_ga64d9591f70db8eb11f530b056ac90285}{fa\_greater\_than} (\textcolor{keywordtype}{void} *, \textcolor{keywordtype}{void} *)
\{
    \textcolor{keywordflow}{return} \hyperlink{group___fa_ga1cc4276643f3d366681ac7ff71fa8b06}{fa\_interface}(\hyperlink{interfaces_8h_a7c337b4de759549a84c656770ce01cd2ae08a92558a44d2796dc2a5df8ff1b3c3}{fa\_order\_i}, a)->greater\_than(a, b);
\}
\end{DoxyCode}
\hypertarget{md__interfaces_Implementing}{}\section{Implementing an interface}\label{md__interfaces_Implementing}
To implement an interface for a reference type, the following has to be provided\-:


\begin{DoxyItemize}
\item Functions implementing the interface methods
\item A dispatch function of type \hyperlink{group___fa_gac13cc6d4ef02b8763045164333cfd763}{fa\-\_\-impl\-\_\-t}
\item A field in the type that points to the dispatch function
\item A construction routine that sets the pointer to the dispatch function
\end{DoxyItemize}

The dispatch function is unique for each type, and performs a case matching on the incoming interface identifiers, returning a pointer to the appropriate interface struct.

As an example, let us write a custom reference type {\ttfamily foo}, implementing \hyperlink{structfa__equal__t}{fa\-\_\-equal\-\_\-t} and \hyperlink{structfa__order__t}{fa\-\_\-order\-\_\-t}.\hypertarget{md__interfaces_Methods}{}\subsection{The methods}\label{md__interfaces_Methods}
The methods are written as ordinary functions, which have the same type as the functions declared in the interface struct. These functions does need not be exported.


\begin{DoxyCode}
\textcolor{keywordtype}{bool} foo\_equal(\textcolor{keywordtype}{void} *a, \textcolor{keywordtype}{void} *b)
\{
    ...
\}

\textcolor{keywordtype}{bool} foo\_less\_than(\textcolor{keywordtype}{void} *a, \textcolor{keywordtype}{void} *b)
\{
    ...
\}

\textcolor{keywordtype}{bool} foo\_greater\_than(\textcolor{keywordtype}{void} *a, \textcolor{keywordtype}{void} *b)
\{
    ...
\}
\end{DoxyCode}
\hypertarget{md__interfaces_Dispatch}{}\subsection{The dispatch function}\label{md__interfaces_Dispatch}
The dispatch function should have the type fa\-\_\-impl\-\_\-t. For example\-:


\begin{DoxyCode}
\hyperlink{group___fa_ga915ddeae99ad7568b273d2b876425197}{fa\_ptr\_t} foo\_impl(\hyperlink{group___fa_gaeb5011c69dfea4d2c41c05a2c95899d0}{fa\_id\_t} interface)
\{
    \textcolor{keyword}{static} \hyperlink{structfa__equal__t}{fa\_equal\_t} foo\_equal\_impl = \{ foo\_equal \};
    \textcolor{keyword}{static} \hyperlink{structfa__order__t}{fa\_order\_t} foo\_order\_impl = \{ foo\_less\_than, foo\_greater\_than \};

    \textcolor{keywordflow}{switch} (interface)
    \{
    \textcolor{keywordflow}{case} \hyperlink{interfaces_8h_a7c337b4de759549a84c656770ce01cd2a9b8bb278c9a713e6ec54d275002e0a01}{fa\_equal\_i}:
        \textcolor{keywordflow}{return} &foo\_equal\_impl;

    \textcolor{keywordflow}{case} \hyperlink{interfaces_8h_a7c337b4de759549a84c656770ce01cd2ae08a92558a44d2796dc2a5df8ff1b3c3}{fa\_order\_i}:
        \textcolor{keywordflow}{return} &foo\_order\_impl;

    \textcolor{keywordflow}{default}:
        \textcolor{keywordflow}{return} NULL;
    \}
\}
\end{DoxyCode}
\hypertarget{md__interfaces_Pointer}{}\subsection{The interface pointer}\label{md__interfaces_Pointer}
The address of the dispatch function has to be the {\itshape first} element of the implementing type. The name of the fields is irrelevant, typically {\ttfamily impl} is used.


\begin{DoxyCode}
\textcolor{keyword}{struct }foo
\{
    \hyperlink{group___fa_gac13cc6d4ef02b8763045164333cfd763}{fa\_impl\_t} impl;     \textcolor{comment}{//  Interface dispatcher}
    ...
\};
\end{DoxyCode}


The creation routine for the type should include a line to set up the {\ttfamily impl} field to the address of the dispatch function. Note that a forward declaration might be necessary here.


\begin{DoxyCode}
\hyperlink{group___fa_ga915ddeae99ad7568b273d2b876425197}{fa\_ptr\_t} foo\_impl(\hyperlink{group___fa_gaeb5011c69dfea4d2c41c05a2c95899d0}{fa\_id\_t} interface);

\textcolor{keyword}{struct }foo *create\_foo()
\{
    \textcolor{keyword}{struct }foo *foo = malloc(\textcolor{keyword}{sizeof}(\_foo));
    foo->impl = &foo\_impl;                      \textcolor{comment}{//  Setting up dispatcher}
    ...
    \textcolor{keywordflow}{return} foo;
\}
\end{DoxyCode}
 