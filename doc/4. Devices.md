
# Devices {#Devices}

[TOC]

# Real time {#RealTime}

The Audio Engine suports real-time audio and midi. The interface for these are similar but most examples below
refer to audio streams. See the \ref DoremirDeviceAudio and \ref DoremirDeviceMidi modules for details.

## Sessions and streams {#SessionDeviceStream}

The Audio Engine provides access to devices through the concepts of *sessions*, and *streams*. While a *device*
provides access to an external audio interface, a *session* provides access to the entire audio system, and a *stream*
to a specific audio computation. These concepts are hierarchical, each stream is associated with a device and each
device with a session.

![Device concept interactions](images/device_states.png)

@note
    The semantics of *streams* have been changed from earlier versions of the audio engine, in which a *stream* was
    a could be stopped and restarted. In the new implementation, streams are one-time entities like sessions.

![Device concept interactions](images/device_states2.png)



### Imperative style {#RealTimeImperative}

To use a real-time device in imperative fashion, the typical paired method pattern should be used. You call 
a creation method to get a session or stream, and a destruction method to release it after use. 

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
#include <doremir/time.h>
#include <doremir/thread.h>
#include <doremir/device/audio.h>

void test()
{   
    typedef doremir_device_audio_t         device_t;
    typedef doremir_device_audio_session_t session_t;
    typedef doremir_device_audio_stream_t  stream_t_;
    typedef doremir_processor_any_t        processor_t;
    
    session_t session = doremir_device_audio_begin_session();

    if (doremir_check(session))
        doremir_print_error(session);

    {
        processor_t    processor = doremir_processor_identity();
        pair_t         devices   = doremir_device_audio_standard(session);
        audio_stream_t stream    = doremir_device_audio_start_stream(devices.first, 
                                       processor, devices.second);

        if (doremir_check(stream))
            doremir_print_error(stream);

        doremir_thread_sleep(doremir_seconds(10));
        doremir_device_audio_stop_stream(stream);
    }

    doremir_device_audio_end_session(session);
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


### Callback style {#RealTimeCallback}

The callback style API use inversion of control to hide createâ€“use-destroy pattern. You provide a
callback to be invoked when the session or stream is valid, and the destruction is handled automatically
after this method has returned. Errors are handled by a special callback, to which you can pass
doremir_print_error, or any user defined function.

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
#include <doremir/thread.h>
#include <doremir/time.h>
#include <doremir/device/audio.h>

void run_callback(doremir_ptr_t data)
{
    doremir_thread_sleep(doremir_seconds(10));
}

void session_callback(doremir_ptr_t session, doremir_ptr_t data)
{
    doremir_ptr_t  processor = doremir_processor_identity();
    doremir_pair_t devices   = doremir_device_audio_standard(session);

    doremir_device_audio_with_stream(devices.first, processor, devices.second,
        run_callback, doremir_print_error, NULL);
}

void test()
{
    doremir_device_audio_with_session(session_callback, doremir_print_error, NULL);
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# Non-realtime {#NonRealTime}

## File streams {#FileStream}

### Imperative style {#ImperativeFileStream}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
#include <doremir/thread.h>
#include <doremir/time.h>
#include <doremir/device/file.h>

void test()
{
    doremir_ptr_t    processor = doremir_processor_id();
    doremir_string_t in        = doremir_device_file_open(doremir_str("test/in.wav"));
    doremir_string_t out       = doremir_device_file_open(doremir_str("test/out.wav"));

    doremir_ptr_t stream = doremir_device_file_run(in, out);

    if (!doremir_check(stream))
    {
        printf("Error!")
    }
    else
    {
        doremir_device_file_wait(stream);
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### Callback style {#CallbackFileStream}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
#include <doremir/thread.h>
#include <doremir/time.h>
#include <doremir/device/file.h>

void test()
{
    doremir_ptr_t    processor = doremir_processor_id();
    doremir_string_t in        = doremir_device_file_open(doremir_str("test/in.wav"));
    doremir_string_t out       = doremir_device_file_open(doremir_str("test/out.wav"));

    doremir_ptr_t stream = doremir_device_file_run(in, out);

    if (!doremir_check(stream))
    {
        printf("Error!")
    }
    else
    {
        doremir_device_file_wait(stream);
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


## Buffer streams {#BufferStream}

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
#include <doremir/thread.h>
#include <doremir/time.h>
#include <doremir/device/buffer.h>

void test()
{
    doremir_ptr_t    processor = doremir_processor_id();
    doremir_string_t in        = doremir_device_buffer_open(doremir_buffer_create(1024));
    doremir_string_t out       = doremir_device_buffer_open(doremir_buffer_create(1024));

    doremir_ptr_t stream = doremir_device_buffer_run(in, out);

    if (!doremir_check(stream))
    {
        printf("Error!")
    }
    else
    {
        doremir_device_buffer_wait(stream);
    }
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~