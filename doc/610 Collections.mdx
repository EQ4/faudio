
# Data structures {#DataStructures}

@anchor DataStructures

@tableofcontents

The Audio Engine include a set of persistent, polymorphic data structures. These
types include [pairs](@ref DoremirPair), [lists](@ref DoremirList), [sets](@ref DoremirSet) and
[maps](@ref DoremirMap). These data structures are used with the message passing interfaces to communicate with audio processors in a
running audio stream.

The *persistence* property means that the data structures are can not change. All functions that would modify a data structure
in a mutable design return a new data structure instead. Persistence also implies that the old data structure value is still
available. Immutability allows data structures to be passed between threads without locking or copying. Persistence means that
data structures can make use of structural sharing to reduce memory usage and improve performance.

The *polymorphic* property means that data structures can store values of any type. Unfortunately there is no way to
encode this in the C type system, therefore all data structures simply store @ref doremir_ptr_t. Any value can be stored
by reference by casting it to a pointer. To store primitive types such as integers or booleans in a data structure, the
[wrap functions](@ref WrapFunctions) should be used. It is *not* safe to store integral types by casting to
pointers.


# Single-ownership {#si}

The Audio Engine use single-ownership semantics for all of its reference types. Each data structure
provides one copy and one destruct function. Each data structure created by a create or copy function
must be destroyed by passing it to a destroy function. The [generic](@ref GenericFunctions) functions
@ref doremir_copy and @ref doremir_destroy can also be used.

For stack variables, the correct usage pattern is to call the destructor whenever the variable holding the
data structure goes out of scope. It is good practice to introduce an extra block to mark out the scope
of the data structure variable.

TODO manage heap allocated variables

TODO deep destruction

~~~~
void test()
{
    {
        doremir_list_t xs = doremir_list(1, 2, 3);
        
        // safe to use xs
        
        doremir_destroy(xs);
    }
    // compiler error if xs is used here
}
~~~~

If a reference type is required to persist beyond the original scope it can be copied or moved. The
@ref doremir_move function does nothing, it just serves as a mnemonic to mark out that ownership is
being transfered.

~~~~
void example1()
{
    doremir_list_t xs = list(1, 2, 3);

    doremir_send(out1, doremir_copy(xs)); // xs copied
    doremir_send(out2, doremir_copy(xs)); // xs copied
    ...

    doremir_destroy(xs);
}

void example2()
{
    doremir_list_t ys = list(1, 2, 3);

    doremir_send(out1, doremir_copy(ys)); // ys copied
    doremir_send(out1, doremir_move(ys)); // ys moved

    // no destroy
}
~~~~


Functions operating on data structures come in two variants: a non-destructive variant that simply construct a new
data structure (the default), and a destructive variant which destructs the old data structures while constructing the new
one. The destructive functions should be used whenever a variable is updated locally.

Note that the destructive functions *invalidates* the original data structure rather than *mutating*
it. Invalidating a data structure does not affect copies.

~~~~
void example3()
{
    doremir_list_t xs;
    doremir_list_t ys;

    xs = doremir_list_empty();          //  xs is []
    xs = doremir_list_dcons(1, xs);     //  old xs destroyed, new xs is [1]
    xs = doremir_list_dcons(2, xs);     //  old xs destroyed, new xs is [2,1]
    ys = doremir_list_cons(3, xs);      //  xs is still [2,1], new ys is [3,2,1]
    ys = doremir_list_dinit(ys);        //  xs is still [2,1], old ys destroyed, new ys is [3,2]

    doremir_destroy(ys);                
    doremir_destroy(xs);                //  both lists destroyed
}
~~~~


# Wrap functions {#WrapFunctions}

The wrap functions can be used to convert primitive types to generic pointers and vice versa. They are the
only safe way to store a non-pointer type in a data structure.

The pointer values returned from a wrap functions have single-ownership semantics and should be freed exactly
once by calling the corresponding unwrap function. There is also a *copy* function, which retrieves a fresh
pointer to the same value which can be freed separately, and a *get* function that retrieves the wrapped
value without destroying the pointer.

Note that wrap functions are implemented without heap allocation whenever possible.

|        | Wrap       | Copy       | Get        | Unwrap         
|--------|------------| -----------| -----------| -----------
| bool   | @ref b     | @ref cb    | @ref gb    | @ref tb    
| int8   | @ref i8    | @ref ci8   | @ref gi8   | @ref ti8   
| int16  | @ref i16   | @ref ci16  | @ref gi16  | @ref ti16  
| int32  | @ref i32   | @ref ci32  | @ref gi32  | @ref ti32  
| int32  | @ref i64   | @ref ci64  | @ref gi64  | @ref ti64  
| double | @ref d     | @ref cd    | @ref gd    | @ref td    


~~~~
list_t xs = list(d(1.4142135623730951), d(3.141592653589793));
double s = td(list_dfold(doremir_add, d(0), xs));
~~~~



