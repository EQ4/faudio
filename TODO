
==========
Additions

* Audio.endAllSession
* Midi.endAllSessions
* Compound (audio + midi) session
    * But not compound devices!
* Get device from stream, get session from device
* Get native stream/device where applicable

* Event
    * First, rest
    * Switch, toggle
    * Fixpoints

* Buffer streams
* File streams

* External devices:
    * FluidSynth
    * QuickTime
    * VST2

----------


* Buffer views?
    * Group buffer with audio type
    * Include sample rate in this?

* Ringbuffer/better FIFO (multi-RW, see paper)
* Better map/set backend (PersistentVector/IntMap or PatriciaTree)

* Memory profiling (leaks related to graphs, messages etc)

* Device detection
    * Windows          
        http://msdn.microsoft.com/en-us/library/windows/desktop/dd371417%28v=vs.85%29.aspx
        * See that CoInitializeEx (or Windows::Foundation::Initialize) is called
        * Implement IMMNotificationClient
        * Create instance of IMMDeviceEnumerator by CoCreate()
        * Pass to IMMDeviceEnumerator::RegisterEndpointNotificationCallback(cb)
        * Pass to IMMDeviceEnumerator::UnregisterEndpointNotificationCallback(cb)

    * See PortAudio tracker
         https://www.assembla.com/spaces/portaudio/tickets/11-add-callback-api-for-detecting-connection-removal-of-devices#/activity/ticket:

* Vector/SIMD support
    * Probably use GCC intrincics (implemented in clang too)
    * Check alignment w.r.t. doremir_type_t.
        http://stackoverflow.com/questions/5118158/using-sse-to-speed-up-computation-store-load-and-alignment
        http://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html
        http://clang.llvm.org/docs/LanguageExtensions.html#vectors-and-extended-vectors

* Possibility to replace interface implementations
    * For example a type could have a set of callbacks attached after
      impl pointer and let the dispatch function return those pointers.
      By default set to default implementations: then add special copy
      function such as:
            orderedBy : (Binary,Ptr) -> Ptr;

      In Haskell, you say
        sortBy (comparing name) dict
      Here it would be
        sort (orderedBy $ \x y -> name x < name y) 
        dict



==========
Issues

* Add CorePlot in build scripts

* Type-safe range(m..n) literal
    * Current one requires map(i8) etc

* Normalize rationals before printing (but not otherwise)

* Lisp frontend
    * Ptr type
        https://github.com/hanshoglund/modulo/issues/27
    * Mangling problems
        https://github.com/hanshoglund/modulo/issues/26
    * Auto wrap of pairs and lists?
    * Call destroy from finalizers for certain types (which?)
    * Wrap functions returning errors with conditions

* Old "linker prefer system library" problem
    * Good explanation here
        http://www.cmake.org/Wiki/CMake_2.6_Notes#Linking_to_System_Libraries

==========
Misc

* Check if we can make Fluidsynth compile against checked in Glib
  binaries instead of /usr/local
  * Done? 
    Tis 28 Aug 2012 22:46:06 CEST

* Set visibility=hidden on OS X. See Apple documentation 'Dynamic
  Library Programming Topics'

* Update MyFramework/Resources/Info.plist, see Apple
  documentation 'Framework Programming Guide'

* DLL name and linkage on Windows
  * Still relevant?
    Tis 28 Aug 2012 22:46:06 CEST
