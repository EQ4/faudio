
/** 
    @addtogroup DoremirList
    
    Immutable list data structure.

    @par Literals
    - `list(1, 2, 3)` 

    @par Implements 
    - doremir_equal_t
    - doremir_order_t
    - doremir_copy_t
    - doremir_destroy_t
    - doremir_dynamic_t
    - doremir_string_show_t
    
    @see 
    - @ref Collections
    
 */
module Doremir.List
{
    import Doremir;
    import Doremir.String;

    type List   = opaque;
            
    // Constructors
    empty       : () -> List;
    single      : Ptr -> List;
    cons        : (Ptr, List) -> List;
    dcons       : (Ptr, List) -> List;
    copy        : List -> List;
    destroy     : List -> Void;

    // Predicates
    isEmpty     : List -> Bool;
    isSingle    : List -> Bool;
    length      : List -> Int;

    // Sequential access
    head        : List -> Ptr;
    tail        : List -> List;
    init        : List -> List;
    dtail       : List -> List;
    dinit       : List -> List;
    last        : List -> Ptr;
    
    // Misc operations
    append      : (List, List) -> List;
    dappend     : (List, List) -> List;
    reverse     : List -> List;
    dreverse    : List -> List;
    sort        : List -> List;
    dsort       : List -> List;

    // Random access
    take         : (Int, List) -> List;
    dtake        : (Int, List) -> List;
    drop         : (Int, List) -> List;
    ddrop        : (Int, List) -> List;
    index        : (Int, List) -> Ptr;
    range        : (Int, Int, List) -> List;
    insert       : (Int, Ptr, List) -> List;
    dinsert      : (Int, Ptr, List) -> List;
    insertRange  : (Int, List, List) -> List;
    dinsertRange : (Int, List, List) -> List;
    remove       : (Int, List) -> List;
    dremove      : (Int, List) -> List;
    removeRange  : (Int, Int, List) -> List;
    dremoveRange : (Int, Int, List) -> List;
    
    // Searching
    has         : (Ptr, List) -> Bool;
    find        : (Pred, List) -> Ptr;
    findIndex   : (Pred, List) -> Int;
    
    // Maps and folds
    map         : (Unary, List) -> List;
    dmap        : (Unary, List) -> List;
    concatMap   : (Unary, List) -> List;
    dconcatMap  : (Unary, List) -> List;
    filter      : (Pred, List) -> List;
    dfilter     : (Pred, List) -> List;
    foldLeft    : (Binary, Ptr, List) -> Ptr;
    dfoldLeft   : (Binary, Ptr, List) -> Ptr;
    concat      : List -> List;
}

