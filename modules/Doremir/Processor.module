
/**
    @addtogroup DoremirProcessor

    Provides signal processors.

    @par Literals
    - `par(p,q)`
    - `seq(p,q)`
    - `fst(p)`
    - `snd(p)`
    - `loop(p)`
    - `delay(n,T)`
    - `id(T)`
    - `const(T,v)`
    - `split(T)`

    @par Implements
    - doremir_processor_interface_t
    - doremir_string_show_t
    - doremir_destroy_t
 */
module Doremir.Processor
{
    import Doremir;
    import Doremir.Time;
    import Doremir.Type;
    import Doremir.Graph;
    import Doremir.Buffer;
    import Doremir.Message;

    /** @struct doremir_processor_info_t
        Information available to a processor at processing time.
      */
    type Info = struct {
        sampleRate  : Double,
        frameSize   : Size,
        sampleTime  : Size,
        totalTime   : Time,
        dispatcher  : Dispatcher,
        bufOffset : Int,
        bufStep   : Int,
        bufLoop   : Int,
        bufSeq    : Int  // merge these?
    };

    /** @typedef doremir_processor_samples_t
        
        The samples manipulated by a processor.
        TODO a vector of raw buffer pointers.
     */
    type Samples = Ptr*;

    /** @interface doremir_processor_interface_t
        
        Processing interface.
        
        Generally there is no need to implement this directly, the primitive
        wrappers or combinator functions in @ref DoremirProcessor can be used to 
        create instances.                                             
      */
    type Interface = struct {
        before  : ((Ptr, Info*) -> Void)*,
        process : ((Ptr, Info*, Samples) -> Void)*,
        after   : ((Ptr, Info*) -> Void)*,

        inputType   : (Ptr -> Type)*,
        outputType  : (Ptr -> Type)*,
        bufferSize  : ((Frames, Ptr) -> Size)*,

        graph : ((Ptr, Info*, Graph) -> Graph)*
    };

    /** @typedef doremir_processor_t

        A type implementing the processor interface.

        If you cast a value to this type, you must assure that it implements
        @ref doremir_processor_interface_t, conversely if you cast a value from
        this type you can assume that it implements @ref doremir_processor_t.
     */
    type Processor = opaque;

    inputType   : Processor -> Type;
    outputType  : Processor -> Type;
    bufferSize  : (Frames, Processor) -> Size;
    address     : Processor -> Ptr;

    graph       : (Processor, Info*, Graph) -> Graph;
    writeGraph  : (Processor,FilePath) -> Void;


    // Primitives
    identity    : Type -> Processor;                            // a ~> a
    constant    : (Type, Type, Ptr) -> Processor;               // a ~> b
    delay       : (Type, Size) -> Processor;                    // a ~> a
    split       : Type -> Processor;                            // a ~> (a,a)
    unary       : (Type, Type, Unary, Ptr) -> Processor;        // a ~> b
    binary      : (Type, Type, Type, Binary, Ptr) -> Processor; // (a,b) ~> c

    parallel    : (Processor, Processor) -> Processor;          // (a~>b), (c~>d) -> (a,c~>b,d)
    sequence    : (Processor, Processor) -> Processor;          // (a~>b), (b~>c) -> (a~>c)
    compose     : (Processor, Processor) -> Processor;          // (a~>b), (b~>c) -> (a~>c)
    loop        : Processor -> Processor;                       // (a,c~>b,d)     -> (a ~> b)


    // Math and logic
    add                 : Type -> Processor;
    subtract            : Type -> Processor;
    multiply            : Type -> Processor;
    power               : Type -> Processor;
    divide              : Type -> Processor;
    modulo              : Type -> Processor;
    absolute            : Type -> Processor;

    not                 : Type -> Processor;
    and                 : Type -> Processor;
    or                  : Type -> Processor;
    xor                 : Type -> Processor;
    bitNot              : Type -> Processor;
    bitAnd              : Type -> Processor;
    bitOr               : Type -> Processor;
    bitXor              : Type -> Processor;
    shiftLeft           : Type -> Processor;
    shiftRight          : Type -> Processor;

    equal               : Type -> Processor;
    lessThan            : Type -> Processor;
    greaterThan         : Type -> Processor;
    lessThanEqual       : Type -> Processor;
    greaterThanEqual    : Type -> Processor;

    acos                : Type -> Processor;
    asin                : Type -> Processor;
    atan                : Type -> Processor;
    cos                 : Type -> Processor;
    sin                 : Type -> Processor;
    tan                 : Type -> Processor;
    exp                 : Type -> Processor;
    log                 : Type -> Processor;
    log10               : Type -> Processor;
    pow                 : Type -> Processor;
    sqrt                : Type -> Processor;
    abs                 : Type -> Processor;
    min                 : Type -> Processor;
    max                 : Type -> Processor;
    fmod                : Type -> Processor;
    remainder           : Type -> Processor;
    floor               : Type -> Processor;
    ceil                : Type -> Processor;
    rint                : Type -> Processor;

    // left        : Type -> Processor;                          // (a,a) ~> a
    // right       : Type -> Processor;                          // (a,b) ~> b
    // swap        : Type -> Processor;                          // (a,b)     ~> (b,a)
    // assoc       : Type -> Processor;                          // (a,(b,c)) ~> ((a,b),c)
    // unassoc     : Type -> Processor;                          // ((a,b),c) ~> (a,(b,c))
    // first       : Processor -> Processor;                     // (a~>b)         -> (a,c ~> b,c)
    // second      : Processor -> Processor;                     // (a~>b)         -> (c,a ~> c,b)

}