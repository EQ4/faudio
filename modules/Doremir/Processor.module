
/**
    @addtogroup DoremirProcessor
    
    Provides signal processors.

    @par Literals
    - `par(p,q)`
    - `seq(p,q)`
    - `fst(p)`
    - `snd(p)`
    - `loop(p)`
    - `delay(n,p)`
    - `time(T)`
    - `id(T)`
    - `const(T,v)`
    - `split(T)`

    @par Implements
    - TODO receiver?        
    - doremir_string_show_t
    - doremir_destroy_t
 */
module Doremir.Processor
{
    import Doremir;
    import Doremir.Time;
    import Doremir.Type;
    import Doremir.Buffer;

    /** @struct doremir_processor_info_t 
        Information available to a processor at processing time. 
      */
    type Info = struct {
        sampleRate  : Double,
        numSamples  : Size,
        sampleTime  : Size,
        totalTime   : Time
    };     
    
    // infoDefault : Info* -> Void;  

    /** @typedef doremir_processor_samples_t
        The samples manipulated by a processor.
     */
    type Samples = Buffer;

    /** @interface doremir_processor_t 
        The abstract processing interface. */
    type Processor = struct {
        before  : ((Ptr, Info*) -> Void)*,
        process : ((Ptr, Info*, Samples) -> Samples)*,
        after   : ((Ptr, Info*) -> Void)*,
        inputType : (Ptr -> Type)*,
        outputType : (Ptr -> Type)*
    };

    /** @typedef doremir_processor_any_t 
        A processor of unkown type.
     */
    type Any = Ptr;   
    
    unary   : (Type, Type, Unary) -> Any;                   // a ~> b
    binary : (Type, Type, Type, Binary) -> Any;             // (a,b) ~> c
    ternary : (Type, Type, Type, Type, Ternary) -> Any;     // (a,b,c) ~> d
    
    identity : Type -> Any;                 // a ~> a
    constant : (Type, Type, Ptr) -> Any;    // a ~> b
    delay    : (Type, Size) -> Any;         // a ~> a
    split    : Type -> Any;                 // a ~> (a,a)

    seq      : (Any, Any) -> Any;           // (a ~> b), (b ~> c) -> (a ~> c)
    par      : (Any, Any) -> Any;           // (a ~> b), (c ~> d) -> (a,c ~> b,d)
    loop     : Any -> Any;                  // (a,c ~> b,d) -> (a ~> b)

    // first    : Any -> Any;                  // (a ~> b) -> (a,c ~> b,c)
    // second   : Any -> Any;                  // (a ~> b) -> (c,a ~> c,b)
    // fold     : Any -> Any;                  // (a,a ~> b) -> [a x n] ~> a ~> b
    // unfold   : Any -> Any;                  // (a ~> b,b) -> a ~> Int ~> [a x n]
    
    // cos         : Type -> Any;
    // sin         : Type -> Any;
    // tan         : Type -> Any;
    // acos        : Type -> Any;
    // asin        : Type -> Any;
    // atan        : Type -> Any;
    // 
    // add         : Type -> Any;
    // subtract    : Type -> Any;
    // multiply    : Type -> Any;
    // divide      : Type -> Any;
    // modulo      : Type -> Any;
    // absolute    : Type -> Any;
    // 
    // and         : Type -> Any;
    // or          : Type -> Any;
    // not         : Type -> Any;
    // bitAnd      : Type -> Any;
    // bitOr       : Type -> Any;
    // bitNot      : Type -> Any;
    // bitXor      : Type -> Any;  
    
}