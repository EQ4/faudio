
/** 
    @addtogroup DoremirEvent
    
    Functional scheduler events.

    @par Literals
    - `never()`
    - `now(v)`
    - `later(t,v)`
    - `delay_event(t,x)`
    - `merge_event(x,y)`
    - `switch_event(p,x,y)`
    - `receive_event(s,a)`
    - `send_event(s,a,x)`

    @par Display
    - `<Event @1000ms 3.1415>`
    

    @par Implements 
    - doremir_destroy_t
    - doremir_string_show_t
 */
module Doremir.Event
{
    import Doremir;
    import Doremir.Std;
    import Doremir.Time;
    import Doremir.Message;

    /** @typedef doremir_buffer_t
        The buffer. 
     */
    type Event = opaque;

    never   : () -> Event;
    now     : Ptr -> Event;
    later   : (Time, Ptr) -> Event;
    delay   : (Time, Event) -> Event;
    // fix     : (Event -> Event)* -> Event;
    merge   : (Event, Event) -> Event;               // rename merge
    switch  : (Event, Event, Event) -> Event;
    receive : (Sender, Address) -> Event;
    send    : (Receiver, Address, Event) -> Event;
    destroy : Event -> Void;
    
    head    : Event -> Event;
    after   : (Event, Event) -> Event;
    before  : (Event, Event) -> Event;
    // select : (Event, Event) -> Event;
    // sample : Event -> Event;
    // toggle : Event -> Event;
    
    // filter      : (Pred, Ptr, Event) -> Event;
    // dfilter     : (Pred, Ptr, Event) -> Event;
    // map         : (Unary, Ptr, Event) -> Event;
    // dmap        : (Unary, Ptr, Event) -> Event;
    // joinMap   : (Unary, Ptr, Event) -> Event;
    // djoinMap  : (Unary, Ptr, Event) -> Event;
    // join      : Event -> Event;
    // djoin     : Event -> Event;

    // Low-level
    offset   : Event -> Time;          // Offset to first occurance            rename offset
    sync     : Event -> Void;
    addSync  : (((Ptr,Sender) -> Void)*, Ptr, Event) -> Void;

    // isNever  : Event -> Bool;          // Definately no occurances
    hasValue : (Time,Event) -> Bool;   // Is an occurance available            rename hasValue
    hasTail  : (Time,Event) -> Bool;   // Is an occurance available            rename hasValue
    value    : (Time,Event) -> Ptr;    // Get the first occurance value        rename value?
    tail     : (Time,Event) -> Event;    
}


