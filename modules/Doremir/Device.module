
/**
    @addtogroup DoremirDevice
    
    Provides input and output devices.

    ## Real time
    
    The Audio Engine suports real-time audio and midi. The APIs for these are similar, to the documentation
    below refers to audio streams only. See the \ref DoremirDeviceAudio and \ref DoremirDeviceMidi modules
    for details.
    
    ### Basic concepts

    The Audio Engine provide dynamic introspection and updating of audio hardware through the concepts of
    *sessions*, *devices* and *streams*. These types are tokens that grants access to the surrounding audio system
    in a well-defined manner. More specifically a *session* grants access to the entire audio system, a *device*
    to a specific input or output port, and a *stream* to an ongoing audio computation. These concepts are
    hierachical: you must obtain a *session* to get a *device*, and a *device* to get a *stream*. Furthermore,
    only one session can be active at a time, and each session can only have one active stream.
    
    Note that the semantics of *streams* have been restricted from earlier versions of the audio engine, in which
    a *stream* was a stateful thing that could be started and stopped repeatedly. In version 2.0 streams are
    one-time entities just like sessions. This means that after stopping a stream you have the choice of 
    starting a new stream, or ending the session. Similarly, after ending a session, the only way to get access
    to the audio system again is to start a new session.
    
    If the audio system setup changes while a session is running (e.g. due to devices being connected or 
    disconnected), these changes will not be visible until a new session is started. In the future we will
    hopefully support some notification mechanism to indicate whenever a new session might be appropriate.

    
    ### Imperative style API
    
    The imperative API use a typical paired method design: you call a creation method to get a session or stream,
    use it, and the call a destruction method to release it. Note the symmetric contructor/destructor methods and
    the if statements for error checking.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    #include <doremir/thread.h>
    #include <doremir/time.h>
    #include <doremir/device/audio.h>
    
    void test() 
    {   
        doremir_ptr_t session = doremir_device_audio_begin_session();

        if (doremir_check(session))
        {
            doremir_print_error(session);
        }
        else
        {
            doremir_ptr_t  processor = doremir_processor_id();
            doremir_pair_t devices   = doremir_device_audio_standard(session);
            doremir_ptr_t  stream    = doremir_device_audio_start(devices.first, processor, devices.second);
            
            if (doremir_check(stream))
            {
                doremir_print_error(stream);
            }
            else
            {
                doremir_thread_sleep(doremir_seconds(10));
            }

            doremir_device_audio_stop(stream);
        }
        
        doremir_device_audio_end_session(session);
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


    ### Callback style API

    The callback style API use inversion of control to hide createâ€“use-destroy pattern. You provide a
    callback to be invoked when the session or stream is valid, and the destruction is handled automatically
    after this method has returned. Errors are handled by a special callback, to which you can pass 
    doremir_print_error, or any user defined function.

    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    #include <doremir/thread.h>
    #include <doremir/time.h>
    #include <doremir/device/audio.h>
    
    void run_callback(doremir_ptr_t data)
    {
        doremir_thread_sleep(doremir_seconds(10));
    }
    
    void session_callback(doremir_ptr_t session, doremir_ptr_t data)
    {
        doremir_ptr_t  processor = doremir_processor_id();
        doremir_pair_t devices   = doremir_device_audio_standard(session);
        
        doremir_device_audio_with_stream(devices.first, processor, devices.second, 
            run_callback, doremir_print_error, NULL);
    }    
    
    void test()
    {
        doremir_device_audio_with_session(session_callback, doremir_print_error, NULL);
    }    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    

    ## Non-realtime
    
    ### File streams
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    #include <doremir/thread.h>
    #include <doremir/time.h>
    #include <doremir/device/file.h>
    
    void test() 
    {           
        doremir_ptr_t    processor = doremir_processor_id();
        doremir_string_t in        = doremir_device_file_open(doremir_str("test/in.wav"));
        doremir_string_t out       = doremir_device_file_open(doremir_str("test/out.wav"));

        doremir_ptr_t stream = doremir_device_file_run(in, out);
        
        if (!doremir_check(stream))
        {
            printf("Error!")
        }
        else
        {
            doremir_device_file_wait(stream);
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
    TODO asynchronous version

    ### Buffer streams
    
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{.c}
    #include <doremir/thread.h>
    #include <doremir/time.h>
    #include <doremir/device/buffer.h>
    
    void test() 
    {           
        doremir_ptr_t    processor = doremir_processor_id();
        doremir_string_t in        = doremir_device_buffer_open(doremir_buffer_create(1024));
        doremir_string_t out       = doremir_device_buffer_open(doremir_buffer_create(1024));

        doremir_ptr_t stream = doremir_device_buffer_run(in, out);
        
        if (!doremir_check(stream))
        {
            printf("Error!")
        }
        else
        {
            doremir_device_buffer_wait(stream);
        }
    }
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    
 */

module Doremir.Device
{
    import Doremir;
}