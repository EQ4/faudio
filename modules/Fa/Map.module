
/** 
    Immutable ordered map data structure.

    @par Literals
    - `map(string("name"),           string("hans"), 
           string("favouriteColor"), string("blue"))`

    @par Requires 
    - fa_order_t

    @par Implements 
    - fa_equal_t
    - fa_copy_t
    - fa_destroy_t
    - fa_dynamic_t
    - fa_string_show_t

    @see 
    - [Data structures](@ref DataStructures)
    
 */
module Fa.Map 
{
    import Fa;
    import Fa.Pair;
    import Fa.List;
    import Fa.String;
    
    type Map = opaque;
    type Key = Ptr;

    // Constructors
    // empty            : () -> Map;
    // copy             : Map -> Map;
    // destroy          : Map -> Void;
    // 
    // // Size
    // size             : Map -> Int;
    // isEmpty          : Map -> Bool;
    // isSingle         : Map -> Bool;
    // 
    // // Lookup function
    // add              : (Key, Ptr, Map) -> Map;
    // set              : (Key, Ptr, Map) -> Map;
    // remove           : (Key, Map) -> Map;
    // dadd             : (Key, Ptr, Map) -> Map;
    // dset             : (Key, Ptr, Map) -> Map;
    // dremove          : (Key, Map) -> Map;
    // addEntry         : (Pair, Map) -> Map;
    // setEntry         : (Pair, Map) -> Map;
    // removeEntry      : (Pair, Map) -> Map;
    // 
    // // Predicates
    // get              : (Key, Map) -> Ptr;
    // hasKey           : (Key, Map) -> Bool;
    // hasElem          : (Ptr, Map) -> Bool;
    // hasEntry         : (Pair, Map) -> Bool;
    // isSubmapOf       : (Map, Map) -> Bool;
    // isProperSubmapOf : (Map, Map) -> Bool;
    // 
    // // Set operations
    // sum              : (Map, Map) -> Map;
    // product          : (Map, Map) -> Map;
    // difference       : (Map, Map) -> Map;
    // // power            : Map -> Map;
    // 
    // // Functor
    // map              : (Unary, Ptr, Map) -> Map;
    // 
    // // Conversions   
    // fromPair         : Pair -> Map;
    // fromList         : List -> Map;
    // toList           : Map -> List;  


    /** Create an empty list. */
    empty            : () -> Map;
    
    /** Copy the given list. */
    copy             : Map -> Map;
    
    /** Destroy the given list. */
    destroy          : Map -> Void;

    // Size
    /** Return the number of elements in the given list. */
    size             : Map -> Int;
    
    /** Return whether the given list is empty. */
    isEmpty          : Map -> Bool;
    
    /** Return whether the given list has a single element. */
    isSingle         : Map -> Bool;

    // Lookup function
    /** Add an element to the map if not present. */
    add              : (Key, Ptr, Map) -> Map;
    
    /** Add an element to the map, replacing if already present. */
    set              : (Key, Ptr, Map) -> Map;
    
    /** Remove the given key if present. */
    remove           : (Key, Map) -> Map;
    
    /** Add an element to the map if not present. */
    dadd             : (Key, Ptr, Map) -> Map;
    
    /** Add an element to the map, replacing if already present. */
    dset             : (Key, Ptr, Map) -> Map;
    
    /** Remove the given key if present. */
    dremove          : (Key, Map) -> Map;
    
    /** Add an element to the map if not present. */
    addEntry         : (Pair, Map) -> Map;
    
    /** Add an element to the map, replacing if already present. */
    setEntry         : (Pair, Map) -> Map;
    
    /** Remove the given key if present. */
    removeEntry      : (Pair, Map) -> Map;

    // Predicates
    /** Return the element stored at the given key, or `null` if the key does not exist. */
    get              : (Key, Map) -> Ptr;
    
    /** Return whether the given key exists in the given map. */
    hasKey           : (Key, Map) -> Bool;
    
    /** Return whether the given element exists in the given map. */
    hasElem          : (Ptr, Map) -> Bool;
    
    /** Return whether the given $(key, element)$ pair element exists in the given map. */
    hasEntry         : (Pair, Map) -> Bool;
    
    /** Whether the first of the given maps is a submap of the second. */
    isSubmapOf       : (Map, Map) -> Bool;
    
    /** Whether the first of the given maps is a proper submap of the second. */
    isProperSubmapOf : (Map, Map) -> Bool;

    // Set operations
    /** Sum or union of the given maps. */
    sum              : (Map, Map) -> Map;
    
    /** Cartesian product of the given maps. */
    product          : (Map, Map) -> Map;
    
    /** Symmetric difference of the given maps. */
    difference       : (Map, Map) -> Map;

    // Functor
    /** Return the result of applying the given function to all elements of the given list. */
    map              : (Unary, Ptr, Map) -> Map;

    // Conversions   
    /** Convert the given pair to a map. */
    fromPair         : Pair -> Map;
    
    /** Convert the given list to a map. */
    fromList         : List -> Map;
    
    /** Convert the given map to a list. */
    toList           : Map -> List;
}

