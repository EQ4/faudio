; 
; 
; ; (defun foo (x y z)
; ;   (+ 1 2)
; ;   (foo bar baz))
; ; 
; ; (defun foo (x) x)
; ; 
; ; (defun fa-audio-begin-session (a b c)
; ;   (if (not pa-mutex)
; ;     (assert nil (c-string "Module not intialized")))
; ;   (fa-inform "Initializing real-time audio session")
; ;   (defvar session :session-type)
; ;     (if (pa-status)
; ;       (progn
; ;         (setq session 
; ;           (coerce (audio-device-error "Overlapping") session-type))))
; ;         (inform "   Starting up PortAudio")
; ;     (Pa-Initialize)
; ;     (setq pa-status t)
; ;     (fa-inform "")
; ;     nil)       
; ; 
; ; 
; ; (defun rslope (rec cur)
; ;   (fa:max curr
; ;     (fa:+ (fa:* 0.999 rec)
; ;       (fa:* 0.001 curr))))
; ; 
; ; (defun sines ()
; ;   (fa:* (fa:n 0.01) (fa:sum (list 440 550 660 770)))) 
; ; 
; ; (defun merge-sort (xs fa:list-type)
; ;   ; (defvar len mid :int left right fa:list-type)
; ;   (setq len (fa:list-length xs))
; ;   (setq mid (/ len 2))
; ;   (if (<= len 1) 
; ;     (return xs)
; ;     (progn 
; ;       (setq left (merge-sort (fa:list-take mid xs)))
; ;       (setq right (merge-sort (fa:list-ddrop mid xs)))
; ;       (return (merge left right))))
; ;   nil)
; ; 
; ; 
; 
; ; (defun fa-audio-begin-session (a b c)
; ;   (if (not pa-mutex)
; ;     (assert nil (c-string "Module not intialized")))
; ;   (fa-inform "Initializing real-time audio session")
; ;   (defvar session :session-type)
; ;     (if (pa-status)
; ;       (progn
; ;         (setq session 
; ;           (coerce (audio-device-error "Overlapping") session-type))))
; ;         (inform "   Starting up PortAudio")
; ;     (Pa-Initialize)
; ;     (setq pa-status t)
; ;     (fa-inform "")
; ;     nil)       
; ;                   
; ; 
; ; (defun fa:signal-to-tree (signal fa:signal-type)
; ;   (case signal
; ;     ((time-signal) 
; ;       (fa:cons "time" (fa:empty)))
; ;     ((random-signal)
; ;       (fa:cons "random" (fa:empty)))
; ;     ((constant-signal value)
; ;       (fa:cons
; ;         (fa:string-to-string (fa:from-double value))
; ;         (fa:empty)))
; ;     ((lift-signal name a)
; ;       (fa:cons name (fa:list a)))
; ;     ((lift2-signal _ a b) 
; ;       (fa:cons name (fa:list a b)))
; ;     ;(input-signal )
; ;     ;(output-signal )
; ;     ))
; ;                  
; ; (defun foo (x y) x)
; ; 
; (defun foo (x) x)
; 
; (defun foo (x y) (+ x y))
; 
; ;(defun foo (x y) (+ x y z))
; 
; (defun remove-duplicates (foo bar baz)
;   (if (fa:list-is-empty xs) xs
;     (if (not (fa:list-has (fa:list-head xs) (fa:list-tail xs))) 
;       xs
;       (fa:list-tail xs))))  
; 
; (defun foo (x)
;   (c-if t (print x))
;   nil)
; 
; (defun foo (x)
;   (c-while t (print x))
;   nil)
; 
; (defun foo (x y)
;   (defvar *foo*)
;   (defvar *bar* :int)
;   (defvar *bar* :int 2)
;   (setq *foo* (+ x y))
;   *foo*) 
; 
; (defun foo (x y)
;   (c-if (fa:less-than "x" 2) (return 1))
;   1)     
;          

; 
; (defun fa:set-set (x set)
;   (defvar i :int (base-index-of x (-> set elems))
;   (if (< i 0)
;     ()
;     )
;   )
; fa_set_t fa_set_set(fa_ptr_t x, fa_set_t set)
; {
;     int i = base_index_of(x, set->elems);
; 
;     if (i < 0) {
;         return new_set(base_insert((-i - 1), x, set->elems));
;     } else {
;         return new_set(base_insert(i, x, base_remove(i, set->elems)));
;         // TODO should be base_dinsert?
;     }
; }
; 
; fa_set_t fa_set_remove(fa_ptr_t x, fa_set_t set)
; {
;     int i = base_index_of(x, set->elems);
; 
;     if (i < 0) {
;         return fa_set_copy(set);
;     } else {
;         return new_set(base_remove(i, set->elems));
;     }
; }
; 
; fa_set_t fa_set_dadd(fa_ptr_t x, fa_set_t set)
; {
;     fa_set_t set2 = fa_set_add(x, set);
;     fa_set_destroy(set);
;     return set2;
; }
; 
; 
; 
; 
; 
; 
; 
; 
; 




(include "stdio.h")
(include "fa/fa.h")
; (include "fa/util.h")
(include "fa/thread.h")

; (defun remove-duplicates (xs)
;   (if (fa:list-is-empty xs) xs
;     (let y (fa:list-head xs) ys (fa:list-tail xs)
;       (if (not (fa:list-has y ys)) 
;         (fa:list-cons y (remove-duplicates ys)) 
;         (remove-duplicates ys)))))  

; (defmacro fa:list ()      (fa:list-empty))
; (defmacro fa:list (a b)   (fa:list-cons a (fa:list b))))
; (defmacro fa:list (a b c) (fa:list-cons a (fa:list b c))))


; (defmacro fa:list (x ...) (fa:list-cons x (fa:list ...))))

(defmacro mul (a b)     (*~ a b))
(defmacro mul (a b c)   (mul a (mul b c)))
(defmacro mul (a b c d) (mul a (mul b c d)))
(defmacro sine (fq) (fa:signal-sin (fa:signal-line fq)))
(defmacro fa:now () (fa:time-create 0 0 0 (fa:ratio-create 0 1)))
(defmacro fa:seconds (s) (fa:time-create 0 0 0 (fa:ratio-create s 1)))
(defmacro fa:quarter-seconds (s) (fa:time-create 0 0 0 (fa:ratio-create s 4)))

(defmacro >=~ (a b) (fa:signal-greater-than-equal a b)) 
(defmacro fa:list ()        (fa:list-empty))
(defmacro fa:list (a)       (fa:list-cons a (fa:list)))
(defmacro fa:list (a b)     (fa:list-cons a (fa:list b)))
(defmacro fa:list (a b c)   (fa:list-cons a (fa:list b c)))
(defmacro fa:list (a b c d) (fa:list-cons a (fa:list b c d)))

(defmacro let (n v x) (progn (defvar n ptr-type v) x))
(defmacro let (n1 v1 n2 v2 x) (let n1 v1 (let n2 v2 x)))

(defmacro >> (a b) (progn a b))
(defmacro >> (a b c) (progn a b c))

(defmacro with-scoped-resource (su td x) (>> su x td))
(defmacro fa:initialize-with-log () (>> (fa:set-log-std) (fa:initialize))) 

(defmacro with-faudio (b)
  (with-scoped-resource (fa:initialize-with-log) (fa:terminate) b))
(defmacro with-faudio (a b) (with-faudio (progn a b)))

(defun fa:signal-if signal-type ((p signal-type) (a signal-type) (b signal-type))
  (+~ 
    (*~ p a)
    (*~ (fa:signal-not p) a)))

(defun fa:put-string (x)
  (fa:print (c-string "%s\n") x)
  nil)



; (define-module fa:audio
;  (defnewtype stream)
;  (define-interface (equality A)
;    (defun == :bool ((x A) (y A)))
;    (defun /= :bool ((x A) (y A)))))



(defun play-proc list-type ((x ptr-type) (y list-type)) 
  (defvar left  ptr-type 
    (*~ (fa:signal-constant 0.2) (fa:signal-trigger "foo" 0))) 
  (defvar right  ptr-type 
    (*~ (fa:signal-constant 0.2) (sine 110)))

  (fa:list left right))


; increment by speed, and change to seek whenever (seek >= 0)
; (defun transport-prim signal-type ((speed signal-type) (seek signal-type))
;   (loop (x)
;     (if (>= seek 0) seek (+ prev-value speed))))

(defun transport-prim-l signal-type (x (prev signal-type))
  (defvar speed signal-type (fa:pair-first x))
  (defvar seek  signal-type (fa:pair-second x))
  (fa:signal-if (>=~ seek (fa:signal-constant 0)) 
    seek
    (+~ (fa-signal:constant 0) speed)))

(defun transport-prim signal-type ((speed signal-type) (seek signal-type))
  (fa:signal-loop transport-prim-l (fa:pair-create speed seek))) 

(defun transport (name)
  (defvar seek signal-type (fa:signal-trigger name -1)) ; send seek values here (just doubles)
  (defvar speed signal-type (fa:signal-trigger "" 1))
  (transport-prim seek speed))

(defun play ()
  (defvar session)
  (defvar in)
  (defvar out)
  (defvar stream)
  (setq session (fa:audio-begin-session))
  (setq in (fa:audio-default-input session))
  (setq out (fa:audio-default-output session))
  (setq stream (fa:audio-open-stream in out play-proc nil))
  (fa:audio-schedule-relative (fa:quarter-seconds 1) (fa:action-send "foo" (fa:from-double 1)) stream)
  (fa:audio-schedule-relative (fa:quarter-seconds 2) (fa:action-send "foo" (fa:from-double 2)) stream)
  (fa:audio-schedule-relative (fa:quarter-seconds 3) (fa:action-send "foo" (fa:from-double 3)) stream)
  (fa:audio-schedule-relative (fa:quarter-seconds 4) (fa:action-send "foo" (fa:from-double 4)) stream)
  
  
  (fa:put-string "Press ENTER to stop...")
  (getchar)
  (fa:audio-end-all-sessions)
  nil
  )
    
(defun main :int ((argc :int) (argv (:const (:pointer (:pointer :char)))))
  (with-faudio
    (fa:put-string "Active!")
    (play))
  ; (fa:initialize)
  ; (fa:set-log-std)

  ; (let 
  ;   foo "x"
  ;   bar "y"
  ;   (fa:put-string (fa:append foo bar)))
  ; 
  ; (if t
  ;   (fa:put-string "t")
  ;   (fa:put-string "f")) 
  ; (fa:put-string
  ;   (fa:pair-create
  ;     (fa:list-join (fa:list (fa:list "hans" "s") (fa:list "t")))
  ;     (fa:list "x" "y")
  ;     )
  ;   )     

  ; (defvar x :int 0)
  ; (defvar y)
  ; (c-while (< x 3)
  ;   (progn
  ;     (setq x (+ 1 x))
  ;     (setq y (fa:list-single "hello"))      
  ;     (fa:set-log-std)
  ;     (fa:thread-sleep 500)         
  ;     (fa:log-info "What?")
  ; 
  ;     (setq y
  ;       (fa:list-cons (fa:from-int32 3) 
  ;         (fa:list-cons (fa:from-int32 2) 
  ;           (fa:list-cons (fa:from-int32 3) 
  ;           (fa:list-cons (fa:from-int32 2) 
  ;           (fa:list-cons (fa:from-int32 31) 
  ;           (fa:list-cons (fa:from-int32 3) 
  ;           (fa:list-cons (fa:from-int32 31) 
  ;             (fa:list-cons (fa:from-int32 3) 
  ;           (fa:list-empty)))))))))) 
  ;     (fa:put-string y)
  ;     (fa:put-string (remove-duplicates y))
  ;     ))  
  ;           
  ; (fa:terminate)
  nil)








